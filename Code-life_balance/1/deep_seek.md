### Анализ задачи

Петя хочет минимизировать свои затраты на обеды в кафе, используя купоны, которые он получает при покупке обедов дороже 100 рублей. Каждый купон позволяет получить один обед бесплатно. Нам нужно:

1. **Вычислить минимальную сумму**, которую Петя потратит за N дней.
2. **Определить количество неиспользованных и использованных купонов** (K1 и K2).
3. **Вывести дни, в которые Петя использовал купоны** в возрастающем порядке.

### Подход к решению

Это задача на **динамическое программирование (DP)**. Мы будем хранить состояние, зависящее от:
- `i` — текущий день (от 0 до N-1).
- `coupons` — количество купонов, которые у Пети есть на начало этого дня.

**Определение состояния:**
`dp[i][coupons]` — минимальная сумма, которую Петя потратит с `i`-го дня до конца, если у него в начале `i`-го дня есть `coupons` купонов.

**Базовый случай:**
Если `i == N` (все дни пройдены), то `dp[N][coupons] = 0`, и количество оставшихся купонов — `coupons`.

**Переходы:**
1. **Если Петя покупает обед в день `i`:**
   - Он тратит `price[i]` рублей.
   - Если `price[i] > 100`, он получает 1 новый купон.
   - Переход в состояние `dp[i+1][coupons + (price[i] > 100 ? 1 : 0)]`.
2. **Если Петя использует купон в день `i` (если `coupons > 0`):**
   - Он не тратит деньги.
   - Теряет 1 купон.
   - Переход в состояние `dp[i+1][coupons - 1]`.

**Выбор оптимального варианта:**
Для каждого дня `i` и количества купонов `coupons` выбираем минимум из:
- Покупки обеда (`price[i] + dp[i+1][coupons + (price[i] > 100 ? 1 : 0)]`).
- Использования купона (`dp[i+1][coupons - 1]`, если `coupons > 0`).

**Восстановление ответа:**
После заполнения таблицы DP нужно восстановить дни, в которые Петя использовал купоны. Для этого идём от начала (день 0) и смотрим, какой выбор (покупка или использование купона) привёл к оптимальному решению.

### Решение на C++

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

const int MAX_DAYS = 101;
const int MAX_COUPONS = 101;

int dp[MAX_DAYS][MAX_COUPONS];  // dp[i][c] — минимальная сумма с i-го дня при c купонах
bool used_coupon[MAX_DAYS][MAX_COUPONS];  // Был ли использован купон в день i при c купонах

int main() {
    int N;
    cin >> N;
    vector<int> prices(N);
    for (int i = 0; i < N; ++i) {
        cin >> prices[i];
    }

    // Инициализация DP
    for (int i = 0; i <= N; ++i) {
        for (int c = 0; c < MAX_COUPONS; ++c) {
            dp[i][c] = INT_MAX;
        }
    }
    dp[N][0] = 0;  // После N дней остаётся 0 купонов (базовый случай)

    // Заполнение DP
    for (int i = N - 1; i >= 0; --i) {
        for (int c = 0; c < MAX_COUPONS; ++c) {
            // Вариант 1: Покупаем обед
            int new_c = c + (prices[i] > 100 ? 1 : 0);
            if (new_c < MAX_COUPONS && dp[i + 1][new_c] != INT_MAX) {
                if (dp[i][c] > prices[i] + dp[i + 1][new_c]) {
                    dp[i][c] = prices[i] + dp[i + 1][new_c];
                    used_coupon[i][c] = false;
                }
            }

            // Вариант 2: Используем купон (если есть)
            if (c > 0 && dp[i + 1][c - 1] != INT_MAX) {
                if (dp[i][c] > dp[i + 1][c - 1]) {
                    dp[i][c] = dp[i + 1][c - 1];
                    used_coupon[i][c] = true;
                }
            }
        }
    }

    // Находим минимальную сумму и оптимальное количество купонов
    int min_cost = INT_MAX;
    int best_coupons = 0;
    for (int c = 0; c < MAX_COUPONS; ++c) {
        if (dp[0][c] < min_cost) {
            min_cost = dp[0][c];
            best_coupons = c;
        } else if (dp[0][c] == min_cost && c > best_coupons) {
            best_coupons = c;  // Выбираем максимум K1 при одинаковой стоимости
        }
    }

    // Восстанавливаем дни использования купонов
    vector<int> coupon_days;
    int current_coupons = best_coupons;
    for (int i = 0; i < N; ++i) {
        if (used_coupon[i][current_coupons]) {
            coupon_days.push_back(i + 1);  // Дни нумеруются с 1
            current_coupons--;
        } else {
            if (prices[i] > 100) {
                current_coupons++;
            }
        }
    }

    // Вывод результатов
    cout << min_cost << endl;
    cout << best_coupons << " " << coupon_days.size() << endl;
    for (int day : coupon_days) {
        cout << day << endl;
    }

    return 0;
}
```

### Объяснение кода

1. **Инициализация DP:**
   - `dp[i][c]` хранит минимальную стоимость с `i`-го дня при `c` купонах.
   - Изначально все значения `INT_MAX`, кроме `dp[N][0] = 0` (после всех дней Петя не тратит деньги).

2. **Заполнение DP:**
   - Для каждого дня `i` и количества купонов `c` рассматриваем:
     - Покупку обеда (если новый купон не превышает лимит).
     - Использование купона (если он есть).
   - Выбираем вариант с минимальной стоимостью.

3. **Поиск оптимального решения:**
   - Находим `min_cost` и `best_coupons` (максимальное `K1` при одинаковой стоимости).

4. **Восстановление дней с купонами:**
   - Проходим по дням и отмечаем, когда Петя использовал купоны.

5. **Вывод результата:**
   - Минимальная стоимость.
   - Количество неиспользованных (`K1`) и использованных (`K2`) купонов.
   - Дни использования купонов в порядке возрастания.

### Пример работы

**Ввод:**
```
5
35
40
101
59
63
```

**Вывод:**
```
235
0 1
5
```

**Объяснение:**
- Петя покупает обеды в дни 1, 2, 3, 4 (стоимость: 35 + 40 + 101 + 59 = 235).
- В день 5 (стоимость 63) он использует купон, полученный за день 3 (101 > 100).
- Итоговая сумма: 235.
- Неиспользованных купонов (`K1`) — 0, использованных (`K2`) — 1.
- День использования купона — 5.
